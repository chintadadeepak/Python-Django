# python is a popular prog language
# in terms of what?
# no of devs using, no of libraries it offer, 
# no of companies using, no of areas it's implemented
# python is a general purpose language, domains such as AI, ML, web-dev, GUI
# python is a interpreted which means compilation and execution at the time one after the other,
# object oriented --> classes and objects
# high level language --> humans can understand

# why should we learn a programming lang and code?
# if we want to perform a task with a machine, we need to instruct the machine first
# as machines can understand only binary, we can't instruct in binary
# so we need a language which was understood by both
# this where prog lang comes into play
# which will be compiled and run on hardware


# arithmetic operations
# + --> add
# - --> sub
# / --> float div --> which also gives you the decimal in quotient
# // --> floor div --> which gives the quotient without decimal
# * --> multi 
# ** --> power of
# % --> remainder
# if you include single quote wrap everything in double quote
# if you include double quote then do in reverse
# if are there, use backslash to skip the meaning of syntax
# print('deepak\'s "laptop"')
# /n is escape sequence character which mean new line
# in order to skip the escape sequence characters meaning use r --> stands for raw string
# raw string does not cares the syntax it's simply prints the string
print(r'c:\docs:\newton')

# variables and list
# variables are the containers which hold certain values, they can be mutable.
# python is weakly typed language so mentioning of datatype is not required.
# at the time of declaration assignment is mandatory, based on which type of the variable is determined.

# using list we can able to store different values of different type.
# we can also form nested lists.
# slicing - fetching certain elements from the list.
# if you do not specify the last index, length will be taken by default.
# in IDLE if you want the previous output, we can underscore to get the previous output.
# indexing --> 0 to n - 1
# reverse indexing starts from --> -1 to -n.
# methods upon list:
1. append() --> inserts element at the end.
2. insert(idx, ele)
3. remove(ele) --> removes the first occurence of the element.
4. pop(index) --> element at the corresponding index will be removed.
5. pop() --> last element will be removed
6. del() --> to delete multiple values involves slicing
7. extend() --> to insert multiple values pass multiple values in the list
8. elementary operations like min, max, sum, sort

# Tuple and Set
# Tuples are similar to lists, the only difference is tuples are immutable.
# indexing and slicing works
# set will store the unique values, does not follow the sequence in which elements are insrted.
# as set is implemented using hashing for efficient retrieval, it does not follow indexing.
# sets are mutable.

# setting path and help command
# using set path we can define the path to command line, but after every login we need to define.
# using environmental variables is a good idea
# using help command and corresponding concept works, direct help command followed by the classname as a argument also works.

# more on variables
# for getting the address of a variable, we can use id command.
# in python, we have data pool concept where if a value is already existed in the memory i.e in the data pool, then no memory allocated for the current variable. instead same address will be given the current variable.
# if a variable is no more used in the program, it'll be given to grabage collection by PVM.
# python does not supports final variables but we can specify the intention using all capital letters.

# datatypes
# 1. None --> absence of value
# 2. Numeric --> int, float, complex, boolean
# 3. list
# 4. tuple
# 5. set
# 6. string
# 7. range --> returns a range of values
# 8. dictionary --> uses key-value machanism.
# keys should be unique
# we can fetch the values using two ways
# 1. using get function which takes key as an argument.
# 2. passing key in the subscript
# we can get all keys and values using keys() and values()

# operators
# arithmetic operators --> +, -, /, //, %, *, **
# assignement operators --> =, += ,-=, *=, /=, //, %=, **=
# unary operator --> ~, -
# relational operators --> <, <=, >, >=, ==, !=
# bitwise operators --> &, |, ^, ~, <<, >>
# logical operatos --> &&, ||, !

# Number system conversion
# decimal to binary --> bin()
# decimal to octal --> oct()
# decimal to hexadecimal --> hex()
# vice versa also possible using int(value, radix)

# ~ tilde sign makes complements the bits within the memory.
# In memory, negative numbers will be stored in the form of 2's complement of a positive number.

# python has rich libraries 
# firstly math module
# functions including ceil, floor, sqrt, pow, factorial

# passing arguments from the command line
# using argv function --> returns string in return

# print function takes into next line
# if we specify end = "" as the second arg the control kept in the sameline itself.


# patterns
l1 = ['a','b','c','d']
l2 = ['p','q','r']

for i in range(len(l1)):
    for j in range(i+1):
        print(l1[j], end=" ")
    
    for k in range(i, len(l2)):
        print(l2[k], end=" ")

    print()

break, continue, pass
break --> used to come forcibly from the loop
continue --> used to skip the statements after the continue statement.
pass --> if we don't have any statements inside the block, such as conditional statements, methods and even
in class as well

# pass inside the conditional statements
if True:
    pass

# pass inside the method
def fun():
    pass

# pass inside the class
class Human:
    pass

# arrays --> similar to list DS, but array stores similar datatype values.
# using array() of array lib, we need to pass two arg 
# 1. typecode --> type of the data 
# example, for integer --> i
# for char it's u --> unicode representation
# 2. list containing the values
# smallCase --> signed
# captialCase --> unsigned
# array class lot of methods including buffer_info()
# buffer_info() returns a tuple containing address and size of the array 
from array import array as arr
# vals = arr('u', ['a', 'e', 'i'])
# for ch in vals:
#     print(ch)

vals = arr('i', [1, 2, 3, 4, 5])
print(vals.buffer_info())
# newArr = arr(vals.typecode, (ele * ele for ele in vals)) 
# fetch value from vals and store in new array
# print(newArr.index(16))

# why numpy
# the array method of array class does not support the multi dimensional array
# hence we need to install a third party library called numpy
# from array import array as arr

import numpy as np
vals = np.array([[1,2,3], [4,5,6]])
print(vals)

# creating an array in different ways
# 1. using numpy array()
# arr = array([1, 2, 3, 4])
# 2. using linspace()
# we need to specify the start, stop and no of parititions we want to divide
# as we are dividing the range the values in the array will be float values
# start and end values are included
# arr = linspace(1, 15, 15)
# 3. using logspace()
# logspace also works similar to linspace() 
# but it deals with power of the specified values
# arr = logspace(1, 5, 5)
# 4. using arange()
# arange() is similar to range() function takes start, end and gap between the values
# arr = arange(1, 10, 2)
# 5. using ones()
# ones() will assign the float values of 1. of specified size
# if we specify explicitly int, it assing int values
# 6. using zeros()
# zeros() working similar to ones()

from numpy import *

arr = zeros((5, 4), int)
print(arr)

# copying an array using view() and copy()
from numpy import array
arr1 = array([1, 2, 3, 4])
# arr2 = arr1 # this step does not mean that we are copying, 
# instead creating a new reference to the same memory location
# copying of an array in python is done in 2 ways
# using view() --> shallow copy --> though different arrays created inside the memory
# one modification will impact the second array
# arr2 = arr1.view()
# arr2[0] = 5
# print(arr1, arr2)
# using copy() --> deep copy --> different memory locations
# one modification will not impact the other
arr2 = arr1.copy()
arr2[0] = 5
print(arr1, arr2)

# working with multi-dimensional arrays and matrices
from numpy import *

# arr1 = arange(1, 10).reshape(3, 3)
# arr2 = arange(1, 10).reshape(3, 3)
# print(arr.dtype) # returns type of the elements
# print(arr.ndim) # returns the dimension of the array i.e 1D, 2D
# print(arr.size) # returns no of elements
# print(arr.shape) # returns the shape --> tuple contains rows, cols

# arr = arr.reshape(4, 3) # using reshape() we can convert a linear array
# to multi-dimensional array
# print("initial: ", arr)
# arr1 = arr1.reshape(3, 3)
# arr2 = 
# print("after reshape: ", arr)
# print(arr)
# using flatten() --> we can convert a multi-dimensional array to linear array
# arr = arr.flatten()
# print('after flatten', arr)
#print(arr)
# numpy has a inbuilt method of matrix class
# which will provide additional features of matrix
# such as matrix multiplication etc
# we can also pass the matrix in the form of string
# where the rows values should be seperated using semicolon
# m1 = matrix(arr1)
# m2 = matrix(arr2)
m1 = matrix('1 2; 3 4')
m2 = matrix('4 3; 2 1')
print(m1 * m2)

# functions --> block or suite of statements which will do perform a task or returns a value
# in python,we define a function using def keyword
# in python, normal variables and functions are differentiated using round brackets
# arguments --> values passed to a function as an input
# actual arguments and formal arguments
# formal arguments --> arguments passed to the function.
# actual arguments --> arguments which were the actual values passed from the called function
# these are 4 types:
# 1. positional --> order in which we have passed the arguments --> wrong order will leads to errors
# 2. keyword --> we specify the keyword at the time of passing
# 3. default --> If the user does not provide the value, it will be replaced with default value, otherwise if user passes then it will be overriden
# 4. variable length --> single variable handles multiple values 
# and that variable internally is a tuple.

# def greet(name, country):
#     print("hello {}, welcome to {} ".format(name, country))

# def person(name, age = 20):
#     print('name: {}, age: {}'.format(name, age))

# person(name = 'Deepak', age = 23)

def add(a, *b): # *b is tuple handling 3 values.
    return a + sum(b)

print(add(2, 3, 4, 5))

# keyword variable length arguments
# in variable length arguments, we have seen that single can handle multiple values
# what if you want pass the keyword as well


def person(**data): # **data holds the keywords and values as well
    for key in data.items(): # key internally represents a tuple of keyword and value
        print(key)



person(name = "deepak", age = 20, city = "vizag")

# global keyword and globals function
# functions will give priority to the local values then global values
# global variables can accessible within the file
# if you want to access the global variables inside the function use global keyword
# situation:
# want to access the global and local variable of same name inside the function
# it can be done using globals()
a = 10
# b = 20
# c = 30
# print(id(a))
def fun():
    # global a # we intended to access the global variable
    a = 8 # refers to local variable 
    # x = globals()['b']
    # print(id(x))
    # print(x)
    # x += 1
    # x = 30
    print(a)
    globals()['a'] = 15
    # print(x)
    
    # not modifying the global instead we declared a variable inside the function
    # print(id(a))
    # print(a)

fun()
print(a)
# print(a)
# print(id(a))
# print(a)


# recursion --> function calling itself again and again 
# until a specified met true
def factRec(n):
    if n == 1:
        return 1 
    return n * factRec(n-1)

def factLoop(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result


n = int(input('enter a number: '))
print(factRec(n))
print(factLoop(n))

# anonymous function 
# function which does not have a name
# filter, map returns a sequence, typecase into a list
# same works for map function
# reduce returns a integer value which belongs to funtools package
# def fun(n):
#     return n * n

# where lambda is used
# map, filter and reduce
# these functions takes lambda as an second argument

# fun = lambda n : n * n
# add = lambda a, b : a + b

# print(fun(6))
# print(add(2, 3))
from functools import reduce
l1 = [1, 2, 3, 4, 5, 6, 7]
l2 = list(filter(lambda n : n % 2 == 0, l1))
l3 = list(map(lambda n : n * n, l2))
result = reduce(lambda a, b : a + b, l3)
print(result)



# decorators --> used for modifying the function behaviour 
# without accessing / touching the file

def div(a, b):
    # if a < b:
    #     a,b = b,a
    return a / b


# define a decorator
def smart_div(func):
    def inner(a, b):
        if a < b:
            a, b = b, a
        
        return func(a, b)
    return inner

div = smart_div(div)
print(div(4, 2))

# module is folder which contains related files
# if you want to access the methods use import statement
from calc import *
add()
sub()

# adv of modules
# 1. modifications will not lead to the conflicts
# 2. code reusability

# __name__ keyword --> name keyword refers to the main method
# i.e entry point of the execution --> the file which you execute first
# when execute the file the __name__ refers to main
# but when you import a file and that file __name__ is module name
# whenever we import a file before the current file execution, imported file contents will be executed first
# if you want to execute only the methods, then wrap name inside the if conditions
from calc import *
print(__name__)


# OOPS --> object oriented programming
# object --> instance of a class
# for generating an object, we need to define the class
# the class will act as blueprint for creating the object
# every object will have two aspects:
# 1. attributes --> variables
# 2. behaviour --> methods

# defining a class
class Computer:
    def config(self):
        print('configuration of : ')


# specify the type of the object using class
com1 = Computer() # creation of an object

# calling of methods
# first way
Computer.config(com1)

# com1 replaces the self
# self is the current calling object

com1.config()
# internally the calling object maps with self

# constructor --> method which will be called at the time of object creation
# in python --> __init__ method is a constructor
# constructor is meant for initializing the variables

# memory for objects will be created inside the heap memory
# size of the object depends on the variables inside the class
# constructor calculates the memory required by an object
# we can compare the values of an object using our own function
class Computer:

    def __init__(self, ram, cpu):
        self.ram = ram
        self.cpu = cpu

    def config(self):
        print('configuration of current machine: {} {}'.format(self.ram, self.cpu))

    def compare(self, other):
        return self.ram == other.ram and self.cpu == other.cpu

com1 = Computer(16, 'Rygen')
com2 = Computer(16, 'Rygen')
if com1.compare(com2):
    print("equal")
else:
    print('unequal')


# types of variables
# 1. instance variables --> variables declared inside the contructor
# 2. static or class variables --> variables declared outside the contructor i.e inside the class
# for accessing the class members we don't need any object
# we can access with the className itself
# modification with one object will not impact the all objects
# because the static variables was not shared among the all objects
# if you modify with the class then only it impacts the all objects
class Student:
    school = 'telusko'
    def __init__(self, name, age):
        self.name = name # these variables are called as instance variables
        self.age = age

    def show(self):
        print('name: {}, age: {}, school: {}'.format(self.name, self.age, self.school))


s1 = Student('deepak', 20)
s2 = Student('bobby', 18)
# Student.school = 'gvp'
s1.show()
s2.show()
print(Student.school)


# types of methods
# 1. instance methods --> methods which deals with instance variables. --> takes self object
# 2. class methods --> methods which deals with class variables. --> takes class object
# 3. static methods --> methods which does not deals with both. --> does not takes anything
# static methods mainly used for accessing files, networking, database connectivity etc.

class Student:
    school = 'telusko'

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        print('name: {}, age: {}'.format(self.name, self.age))

    # static methods need a decorators --> i.e @classmethod
    @classmethod
    def class_met(cls): # argument name should be cls
        print(cls.school)

    @staticmethod
    def static_met():
        print('connecting..')

s1 = Student('deepak', 20)
s2 = Student('bobby', 18)

s1.show()
s2.show()

Student.class_met()
Student.static_met()


# inner class
# class inside a class
# so far we assumed that class consists of variables and methods
# but the twist is it can also contain the class
# object for laptop can be done in two ways
# 1. inside the constructor of Student
# 2. outside the class using Student class

class Student:

    def __init__(self, name, rollno):
        self.name = name
        self.rollno = rollno
        # self.lap = self.Laptop(cpu, ram) # this first way of initialization

    def studentShow(self):
        print('name: {}, rollno: {}'.format(self.name, self.rollno))


    class Laptop:
        def __init__(self, cpu, ram):
            self.cpu = cpu
            self.ram = ram

        def laptopShow(self):
            print('cpu: {}, ram: {}'.format(self.cpu, self.ram))



s1 = Student('deepak', 20)
s2 = Student('bobby', 18)

lap1 = s1.Laptop('i5', 8)
lap2 = s2.Laptop('i7', 16)

lap1.laptopShow()
lap2.laptopShow()
# lap2.laptopShow()
# s1.studentShow()
# # s2.studentShow()
# s1.lap.laptopShow()














